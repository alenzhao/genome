#!/usr/bin/env genome-perl

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
};

use strict;
use warnings;

use above "Genome";
use Genome::Utility::Test qw(is_equal_set);
use Genome::Test::Factory::Model::ReferenceAlignment;

require File::Temp;
use Test::More tests => 11;
use Test::Exception;

use_ok('Genome::Model') or die;

# SUB CLASS TO TEST GENOME::MODEL
class Genome::Model::TestyMcTesterson {
    is => 'Genome::ModelDeprecated',
    has => [
        foo => { 
            is_param => 1, is_optional => 1, is_mutable => 1, is_many => 0,
            via => 'inputs', to => 'value_id', where => [name => 'foo', value_class_name => 'UR::Value', ],
        },
        baz => { 
            is_param => 1, is_optional => 1, is_mutable => 1, is_many =>1,
            via => 'inputs', to => 'value_id', 
            where => [name => 'baz', value_class_name => 'UR::Value'],
        },
    ],
    has_constant => [
        sequencing_platform => { value => 'solexa', },
    ],
};

class Genome::Model::Build::TestyMcTesterson {
    is => 'Genome::Model::Build',
};

my $pp;
subtest 'ProcessingProfile and Command are autogenerated' => sub {
    plan tests => 9;

    # Test __extend_namespace__ PP and Command shjould be autogenerated
    my $pp_class = eval{ Genome::ProcessingProfile::TestyMcTesterson->class; };
    is($pp_class, 'Genome::ProcessingProfile::TestyMcTesterson', 'Genome::ProcessingProfile::TestyMcTesterson auto generated');
    my $command_class = eval{ Genome::Model::TestyMcTesterson::Command->class; };
    is($command_class, 'Genome::Model::TestyMcTesterson::Command', 'Genome::Model::TestyMcTesterson::Command auto generated');
    isa_ok($command_class, 'Command::Tree');
    is($command_class->sub_command_category, 'type specific', 'command sub command category');
    is($command_class->__meta__->doc, 'operate on testy mc testerson models/builds', 'command doc');

    # PP
    $pp = $pp_class->create(
        name => '__TEST_PP__',
    );
    ok($pp, 'define processing profile') or die;
    is($pp->type_name, 'testy mc testerson', 'processing profile type name');
    ok($pp->can('baz'), 'processing profile can baz');
    ok($pp->can('foo'), 'processing profile can foo');
};

my($sample, $library, $project, $tmpdir);
subtest 'define required data for create' => sub {
    plan tests => 4;

    # SUBJECT
    $sample = Genome::Sample->__define__(
        id => -654321,
        name => 'TEST-00',
    );
    ok($sample, 'define sample') or die;
    $library = Genome::Library->__define__(
        name => $sample->name.'-testlib',
        sample_id => $sample->id,
    );
    ok($library, 'define library');

    # PROJECT
    $project = Genome::Project->__define__(name => '__TEST_PROJECT__');
    ok($project, 'define project');

    # DATA DIR
    $tmpdir = File::Temp::tempdir(CLEANUP => 1);
    ok(-d $tmpdir, 'create tmpdir');
};

subtest 'creation failures' => sub {
    plan tests => 4;

    # fail - no pp
    my $model_fail = eval {
        Genome::Model->create(
            name => '__TEST_MODEL__',
            subject_id => $sample->id,
            subject_class_name => $sample->class,
        );
    };
    ok(!$model_fail, 'failed to create model w/o pp');

    # fail - no invalid pp
    $model_fail = eval {
        Genome::Model->create(
            name => '__TEST_MODEL__',
            processing_profile_id => -999999,
            subject_id => $sample->id,
            subject_class_name => $sample->class,
        );
    };
    ok(!$model_fail, 'failed to create model w/ invalid pp');

    # fail - no subject
    $model_fail = eval{
        Genome::Model->create(
            name => '__TEST_MODEL__',
            processing_profile => $pp,
        );
    };
    ok(!$model_fail, 'failed to create model w/o subject');

    # fail - invalid subject
    $model_fail = eval{
        Genome::Model->create(
            name => '__TEST_MODEL__',
            processing_profile => $pp,
            subject_id => -999999,
            subject_class_name => $sample->class,
        );
    };
    ok(!$model_fail, 'failed to create model w/ invalid subject');
};

my $model;
subtest 'create' => sub {
    plan tests => 3;

    $model = Genome::Model->create(
        name => '__TEST_MODEL__',
        processing_profile => $pp,
        subject_id => $sample->id,
        subject_class_name => $sample->class,
        projects => [ $project ],
    );
    ok($model, 'create model');
    is_deeply([$model->projects], [$project], 'add project to model');

    # recreate fails
    my $model_fail = eval {
        Genome::Model->create(
            name => '__TEST_MODEL__',
            processing_profile => $pp,
            subject_id => $sample->id,
            subject_class_name => $sample->class,
        );
    };
    ok(!$model_fail, 'failed to recreate model');
};

subtest 'model inputs' => sub {
    plan tests => 3;

    $model->foo('bar');
    is($model->foo, 'bar', 'model foo');
    $model->add_baz('abc');
    $model->add_baz('xyz');
    is_deeply([$model->baz], [qw/ abc xyz /], 'model baz');
    is_deeply([sort map { $_->value_id } $model->inputs], [qw/ abc bar xyz /], 'model inputs');
};

subtest 'instrument data' => sub {
    plan tests => 7;

    Genome::InstrumentData::Solexa->queue_warning_messages(1);
    Genome::InstrumentData::Solexa->dump_warning_messages(0);
    Genome::Model->queue_warning_messages(1);
    Genome::Model->dump_warning_messages(0);

    my @instrument_data;
    for my $i (1..2) {
        push @instrument_data, Genome::InstrumentData::Solexa->create(
            sequencing_platform => 'solexa',
            library_id => $library->id,
            read_length => 100,
            clusters => 100,
        );
    }
    is(@instrument_data, 2, 'create instrument data');

    my $data_sorter = Genome::InstrumentData::Solexa->__meta__->id_property_sorter;
    @instrument_data = sort $data_sorter @instrument_data;

    # compatible
    my @compatible_id = $model->compatible_instrument_data;
    is_deeply(
        \@compatible_id,
        \@instrument_data,
        "compatible_instrument_data"
    );

    # available/unassigned
    can_ok($model, 'unassigned_instrument_data'); # same as available
    my @available_id = $model->available_instrument_data;
    is_deeply(
        \@available_id,
        \@compatible_id,
        "available_instrument_data"
    );

    # ASSIGN INST DATA
    my @instdata_inputs;
    for my $instrument_data ( @instrument_data ) {
        push @instdata_inputs, $model->add_input(name => 'instrument_data', value => $instrument_data);
    }
    $instdata_inputs[0]->filter_desc('forward-only');
    my @model_instrument_data = $model->instrument_data; # check via ida
    is_deeply(\@model_instrument_data, \@instrument_data, 'model instrument data via ida');

    my @got_instdata_warnings = map { $_->warning_messages() }
                                @instrument_data;
    my @expected_instdata_warnings = map { sprintf('Failed to resolve import_format for / (%s) for %s (%s): ',
                                                    $_->id, $_->sample_name, $_->sample_id) }
                                        @instrument_data;
    is_deeply(\@got_instdata_warnings,
              \@expected_instdata_warnings,
              'warnings from instrument data');


    my @got_model_warnings = $model->warning_messages();
    my @expected_model_warnings = map { sprintf('No analysis project associated with model %s (%s).',
                                                $_->name, $_->id) }
                                    ( $model, $model);
    is_deeply(\@got_model_warnings,
              \@expected_model_warnings,
              'warnings from Model');

    Genome::InstrumentData::Solexa->dump_warning_messages(1);
    Genome::InstrumentData::Solexa->queue_warning_messages(0);
    Genome::Model->dump_warning_messages(1);
    Genome::Model->queue_warning_messages(0);
};

subtest 'builds' => sub {
    plan tests => 18;

    # create these in reverse order because of negative ids
    my @builds;
    for my $i (1..2) {
        unshift @builds, Genome::Model::Build->create(
            model => $model,
            data_directory => $tmpdir.'/build'.$i,
        );
    }

    is(@builds, 2, 'create builds');
    my @model_builds = $model->builds;
    is_equal_set(\@model_builds, \@builds, 'model builds');

    # Fix the date_scheduled on the builds because completed_builds sorts by it
    my $time = time();
    my @timestamps = map { Date::Format::time2str(UR::Context->date_template, $time + $_) } (3, 5, 7, 9);
    $builds[0]->date_scheduled($timestamps[0]);
    $builds[1]->date_scheduled($timestamps[1]);

    # one succeeded, one running
    $builds[0]->status('Succeeded');
    $builds[0]->date_completed($timestamps[2]);
    is($builds[0]->status, 'Succeeded', 'build 0 is succeeded');
    $builds[1]->status('Running');
    is($builds[1]->status, 'Running', 'build 1 is running');

    my @completed_builds = $model->completed_builds;
    is_deeply(\@completed_builds, [$builds[0]], 'completed builds');
    is_deeply([$model->last_complete_build], [$builds[0]], 'last completed build');
    is($model->last_complete_build_id, $builds[0]->id, 'last completed build id');

    my @succeed_builds = $model->succeeded_builds;
    is_deeply(\@succeed_builds, [$builds[0]], 'succeeded builds');
    is_deeply([$model->last_succeeded_build], [$builds[0]], 'last succeeded build');
    is($model->last_succeeded_build_id, $builds[0]->id, 'last succeeded build id');

    my @running_builds = $model->running_builds;
    is_deeply(\@running_builds, [$builds[1]], 'running builds');

    # both succeeded
    $builds[1]->status('Succeeded');
    $builds[1]->date_completed($timestamps[3]);
    is($builds[1]->status, 'Succeeded', 'build 1 is now succeeded');

    @completed_builds = $model->completed_builds;
    is_deeply(\@completed_builds, \@builds, 'completed builds');
    is_deeply([$model->last_complete_build], [$builds[1]], 'last completed build');
    is($model->last_complete_build_id, $builds[1]->id, 'last completed build');
    @succeed_builds = $model->succeeded_builds;
    is_deeply(\@succeed_builds, \@builds, 'succeeded builds');
    is_deeply([$model->last_succeeded_build], [$builds[1]], 'last succeeded build');
    is($model->last_succeeded_build_id, $builds[1]->id, 'last succeeded build id');
};

subtest 'copy' => sub {
    plan tests => 22;

    my $model2 = $model->copy(auto_build_alignments => 1);
    ok($model2, 'copy override auto_build_alignments');
    ok(_are_model_inputs_the_same($model, $model2), 'inputs match');
    ok(!$model2->auto_assign_inst_data, 'auto_assign_inst_data');
    ok($model2->auto_build_alignments, 'auto_build_alignments');

    $model->auto_assign_inst_data(1);
    my $model3 = $model->copy(instrument_data => undef);
    ok($model3, 'copy w/o inst data');
    is_deeply(
        [map { $_->value_id } $model3->inputs],
        [map { $_->value_id } grep { $_->name ne 'instrument_data' } $model->inputs],
        'inputs match',
    );
    ok($model3->auto_assign_inst_data, 'auto_assign_inst_data');
    ok(!$model3->auto_build_alignments, 'auto_build_alignments');

    my $model4 = $model->copy(foo => 'BAR');
    ok($model4, 'copy w/ override single input foo');
    is_deeply([$model4->instrument_data], [$model->instrument_data], 'inst data matches');
    is($model4->foo, 'BAR', 'override foo');

    my $model5 = $model->copy(
        name => 'BLAH!',
        instrument_data => undef,
        baz => [qw/ pdq /],
    );
    ok($model5, 'copy w/ override multi input baz');
    is($model5->name, 'BLAH!', 'set model name');
    is_deeply([$model5->instrument_data], [], 'did not copy inst data');
    is($model5->foo, $model->foo, 'foo');
    is_deeply([$model5->baz], [qw/ pdq /], 'override baz');

    $model->dump_error_messages(0);
    my $got_error_message;
    my $o = UR::Observer->create(
        subject => $model,
        aspect => 'error_message',
        callback => sub {
            my($self, $aspect, $message) = @_;
            $got_error_message = $message;
            pass('got error_message');
        },
    );
    ok(!$model->copy(foo => [qw/ BAR baz /]), 'failed to copy model overriding single input w/ multiple values');
    like($got_error_message,
        qr(Cannot override singular input with multiple values),
        'Expected error message about multiple values');
    ok(!$model->copy(unknown => [qw/ BAR baz /]), 'failed to copy model w/ unknown override');
    like($got_error_message,
        qr(Unrecognized overrides sent to model copy),
        'Expected error message about unrecognized overrides');
    $model->dump_error_messages(1);
};

subtest 'should_run_as' => sub {
    plan tests => 2;

    my $model = Genome::Test::Factory::Model::ReferenceAlignment->setup_object();

    no warnings qw(once redefine);
    local *Genome::Model::_can_run_as = sub { 1 };

    ok(!$model->should_run_as, 'run_as defaults to current user so should_run_as should be false');

    $model->run_as('Elvis');
    ok($model->should_run_as, 'should_run_as should be true if current user is not Elvis');
};

subtest 'model create() failure does not delete existing builds' => sub {
    plan tests => 4;

    my $model_id = UR::Object::Type->autogenerate_new_object_id_uuid();
    my @builds;
    for my $i ( 1 .. 2 ) {
        push @builds, Genome::Model::Build::TestyMcTesterson->__define__(
            model_id => $model_id,
            data_directory => $tmpdir.'/build'.$i,
        );
    }

    subtest 'non existent subject' => sub {
        plan tests => 3;

        my $non_existent_subject_id = UR::Object::Type->autogenerate_new_object_id_uuid();
        throws_ok {
                Genome::Model::TestyMcTesterson->create(
                    genome_model_id => $model_id,
                    subject_id => $non_existent_subject_id,
                    subject_class_name => $sample->class,
                    processing_profile => $pp,
                );
            }
            qr(Could not resolve subject for model),
            'Expected model create() failure';
        isa_ok($_, 'Genome::Model::Build', 'Build') foreach (@builds);
    };

    subtest 'missing processing profile' => sub {
        plan tests => 3;

        throws_ok {
                Genome::Model::TestyMcTesterson->create(
                    genome_model_id => $model_id,
                    subject_id => $sample->id,
                    subject_class_name => $sample->class,
                );
            }
            qr(processing profile),
            'Expected model create() failure';
        isa_ok($_, 'Genome::Model::Build', 'Build') foreach (@builds);
    };

    subtest 'default model name' => sub {
        plan tests => 3;

        no warnings 'once';
        local *Genome::Model::TestyMcTesterson::default_model_name = sub { undef };
        throws_ok {
                Genome::Model::TestyMcTesterson->create(
                    genome_model_id => $model_id,
                    subject_id => $sample->id,
                    subject_class_name => $sample->class,
                    processing_profile => $pp,
                );
            }
            qr(Could not resolve default name for model),
            'Expected model create() failure';
        isa_ok($_, 'Genome::Model::Build', 'Build') foreach (@builds);
    };

    subtest 'verify no other models with same name and type exist' => sub {
        plan tests => 4;

        my $conflicting_name = 'conflict';
        my $other_model = Genome::Model::TestyMcTesterson->create(
                name => $conflicting_name,
                genome_model_id => $model_id,
                subject_id => $sample->id,
                subject_class_name => $sample->class,
                processing_profile => $pp,
            );
        ok($other_model, 'Created model');

        throws_ok {
                Genome::Model::TestyMcTesterson->create(
                    name => $conflicting_name,
                    subject_id => $sample->id,
                    subject_class_name => $sample->class,
                    processing_profile => $pp,
                );
            }
            qr(Found the above model with the same name and type name),
            'Expected model create() failure';
        isa_ok($_, 'Genome::Model::Build', 'Build') foreach (@builds);
    };
};

sub _are_model_inputs_the_same {
    my ($m1, $m2, $skip) = @_;
    my @i1 = $m1->inputs;
    my @i2 = $m2->inputs;
    for (my $i = 0; $i <= $#i1; $i++) {
        for my $p (qw/ name value_class_name value_id filter_desc /) {
            next if not defined $i1[$i]->$p and not defined $i2[$i]->$p; # ok
            return if not defined $i1[$i]->$p or not defined $i2[$i]->$p or $i1[$i]->$p ne $i2[$i]->$p;
        }
    }
    return 1;
}

