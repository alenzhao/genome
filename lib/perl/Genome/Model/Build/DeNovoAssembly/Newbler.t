#!/usr/bin/env genome-perl

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
};

use strict;
# This is needed because of a bug in List::MoreUtils of our ancient perl version.
#use warnings FATAL => 'all', NONFATAL => 'deprecated';
use warnings;

use above 'Genome';
use Workflow::Simple;

use File::Compare;
use File::Temp;
use List::MoreUtils;

use Test::More;

if (Genome::Sys->arch_os ne 'x86_64') {
    plan skip_all => 'requires 64-bit machine';
}

use_ok('Genome::Model::Build::DeNovoAssembly::Newbler') or die;

my $base_dir = Genome::Config::get('test_inputs') . '/Genome-Model/DeNovoAssembly';
my $archive_path = $base_dir.'/inst_data/-7777/archive.tgz';
ok(-s $archive_path, 'inst data archive path') or die;
my $example_dir = $base_dir.'/newbler_v8';
ok(-d $example_dir, 'example dir') or die;
my $tmpdir_template = "/DeNovoAssembly-Newbler.t-XXXXXXXX";
my $tmpdir = File::Temp::tempdir($tmpdir_template, CLEANUP => 1, TMPDIR => 1);
ok(-d $tmpdir, 'temp dir: '.$tmpdir);


my $taxon = Genome::Taxon->create(
    name => 'Escherichia coli TEST',
    domain => 'Bacteria',
    current_default_org_prefix => undef,
    estimated_genome_size => 4500000,
    current_genome_refseq_id => undef,
    ncbi_taxon_id => undef,
    ncbi_taxon_species_name => undef,
    species_latin_name => 'Escherichia coli',
    strain_name => 'TEST',
);
ok($taxon, 'taxon') or die;
my $sample = Genome::Sample->create(
    id => -1234,
    name => 'TEST-000',
);
ok($sample, 'sample') or die;
my $library = Genome::Library->create(
    id => -12345,
    name => $sample->name.'-testlibs',
    sample_id => $sample->id,
    library_insert_size => 260,
);
ok($library, 'library') or die;

my $instrument_data = Genome::InstrumentData::Solexa->create(
    id => -7777,
    sequencing_platform => 'solexa',
    read_length => 100,
    subset_name => '8-CGATGT',
    index_sequence => 'CGATGT',
    run_name => 'XXXXXX/8-CGATGT',
    run_type => 'Paired',
    flow_cell_id => 'XXXXXX',
    lane => 8,
    library => $library,
    archive_path => $archive_path,
    median_insert_size => 260,
    clusters => 15000,
    fwd_clusters => 15000,
    rev_clusters => 15000,
    analysis_software_version => 'not_old_iilumina',
);
ok($instrument_data, 'instrument data');
ok($instrument_data->is_paired_end, 'inst data is paired');
ok(-s $instrument_data->archive_path, 'inst data archive path');

my $pp = Genome::ProcessingProfile::DeNovoAssembly->create(
    name => 'De Novo Assembly Newbler Test',
    assembler_name => 'newbler de-novo-assemble',
    assembler_version => 'mapasm454_source_03152011',
    assembler_params => '-consed -rip',
    post_assemble => 'standard-outputs --min_contig_length 50',
);
ok($pp, 'pp') or die;

my $model = Genome::Model::DeNovoAssembly->create(
    processing_profile => $pp,
    subject_name => $taxon->name,
    subject_type => 'species_name',
    center_name => 'WUGC',
);
ok($model, 'soap de novo model') or die;
ok($model->add_instrument_data($instrument_data), 'add inst data to model');

my $build = Genome::Model::Build::DeNovoAssembly->create(
    model => $model,
    data_directory => $tmpdir,
);
ok($build, 'created build');
my $example_build = Genome::Model::Build->create(
    model => $model,
    data_directory => $example_dir,
);
ok($example_build, 'create example build');


my $workflow = $model->_resolve_workflow_for_build($build);
$workflow->validate();
ok($workflow->is_valid, 'workflow validated');

my %workflow_inputs = $model->map_workflow_inputs($build);
my %expected_workflow_inputs = (
        build => $build,
        instrument_data => [$instrument_data],
    );
is_deeply(\%workflow_inputs, \%expected_workflow_inputs,
    'map_workflow_inputs succeeded');


my $workflow_xml = $workflow->save_to_xml();
my $success = Workflow::Simple::run_workflow($workflow_xml, %workflow_inputs);
ok($success, 'workflow completed');


my @existing_assembler_input_files = $build->existing_assembler_input_files;
is(@existing_assembler_input_files, 1, 'assembler input files exist');

my @example_existing_assembler_input_files = $example_build->existing_assembler_input_files;
is(@example_existing_assembler_input_files, 1,
    'example assembler input files exist');
is(File::Compare::compare($existing_assembler_input_files[0],
        $example_existing_assembler_input_files[0]),
    0, 'assembler input file matches',
);

my %assembler_params = $build->assembler_params;
is_deeply(
    \%assembler_params,
    {
        'version' => 'mapasm454_source_03152011',
        'input_files' => [ $build->data_directory.'/-7777-input.fastq' ],
        'rip' => 1,
        'consed' => 1,
        'output_directory' => $build->data_directory,
    },
    'assembler params',
);

# check build output files
for my $file_name (qw/ all_contigs_fasta_file all_contigs_qual_file all_contigs_ace_file / ) {
    my $file = $build->$file_name;
    ok(-s $file, "Build $file_name exists");
    my $example_file = $example_build->$file_name;
    ok(-s $example_file, "Example $file_name exists");
    is(File::Compare::compare($file, $example_file), 0,
        "Generated $file_name matches example file");
}

#check post asm output files
foreach my $file_name (qw/
    454Contigs.ace.1 Pcap.454Contigs.ace
    gap.txt contigs.quals contigs.bases
    reads.placed readinfo.txt
    reads.unplaced reads.unplaced.fasta
    supercontigs.fasta supercontigs.agp
    /) {
    my $example_file = $example_dir.'/consed/edit_dir/'.$file_name;
    ok(-e $example_file, "$file_name example file exists");
    my $file = $build->data_directory.'/consed/edit_dir/'.$file_name;
    ok(-e $file, "$file_name file exists");
    is(File::Compare::compare($file, $example_file), 0,
        "$file_name files match");
}

ok( -s $example_build->stats_file, 'Example build stats file exists' );
ok( -s $build->stats_file, 'Test created stats file' );
is(File::Compare::compare($example_build->stats_file, $build->stats_file), 0,
    'Stats files match' );

my %expected_metrics = (
    'assembly_length' => 65818,
    'contigs_average_length' => 210,
    'contigs_count' => 314,
    'contigs_length' => 65818,
    'contigs_major_average_length' => 603,
    'contigs_major_count' => 4,
    'contigs_major_length' => 2411,
    'contigs_major_n50_count' => 2,
    'contigs_major_n50_length' => 591,
    'contigs_n50_count' => 125,
    'contigs_n50_length' => 208,
    'genome_size' => '4500000',
    'insert_size' => '260',
    'major_contig_threshold' => '500',
    'reads_assembled' => 2412,
    'reads_assembled_duplicate' => 0,
    'reads_assembled_success' => '0.080',
    'reads_attempted' => 30000,
    'reads_processed' => 30000,
    'reads_processed_success' => '1.000',
    'supercontigs_average_length' => 210,
    'supercontigs_count' => 314,
    'supercontigs_length' => 65818,
    'supercontigs_major_average_length' => 603,
    'supercontigs_major_count' => 4,
    'supercontigs_major_length' => 2411,
    'supercontigs_major_n50_count' => 2,
    'supercontigs_major_n50_length' => 591,
    'supercontigs_n50_count' => 125,
    'supercontigs_n50_length' => 208,
);

my @build_metric_names = sort(map {$_->name} $build->metrics);
my @unique_build_metric_names = sort(List::MoreUtils::uniq(@build_metric_names));

is_deeply(\@build_metric_names, \@unique_build_metric_names,
    'no duplicate metrics');

my @expected_metric_names = sort(keys %expected_metrics);
is_deeply(\@build_metric_names, \@expected_metric_names,
    'expected metric names match');

for my $metric_name (@build_metric_names) {
    is($build->get_metric($metric_name), $expected_metrics{$metric_name},
        "metric ok: '$metric_name'" );
}

done_testing();
